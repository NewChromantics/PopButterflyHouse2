<!DOCTYPE html>
<html lang="en">
<head>
	<title>Butterfly House - WebVR</title>
	<meta charset="utf-8" />
	
	<style type="text/css">
		
		body
		{
		xxxbackground-color:	#0ff;
		color:				#000;
		font-family:		"futura-pt",sans-serif;
		margin:				0px;
		padding:			0px;
		overflow:			hidden;
		}
	</style>
</head>
<body>
	<script src="PopGl.js"></script>
	<canvas id="glcanvas" width="100" height="100">
		Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
	</canvas>
<script>


var VertexShader = `
attribute vec2 a_position;
varying vec2 uv;
void main()
{
	vec2 Pos2 = mix( vec2(-1,-1), vec2(1,1), a_position );
	gl_Position = vec4(Pos2, 0.0, 1.0);
	uv = vec2( a_position.x, 1.0-a_position.y);
	
	uv.x = mix( 0.0, 1.0, uv.x );
	uv.y = mix( 0.0, 1.0, uv.y );
}
`;

var FragShader_SdfHorse = `
precision highp float;
uniform float Time;
varying vec2 uv;
uniform sampler2D SdfTexture;
uniform sampler2D HorseTexture;
uniform int ColourCount;
uniform vec3 Colour0;
uniform vec3 Colour1;
uniform vec3 Colour2;
uniform vec3 Colour3;
uniform vec3 Colour4;
uniform vec3 Colour5;
uniform vec3 Colour6;
uniform vec3 Colour7;
uniform vec3 Colour8;
uniform vec3 Colour9;

vec3 GetColour(int Index)
{
	if ( Index == 0 )	return Colour0;
	if ( Index == 1 )	return Colour1;
	if ( Index == 2 )	return Colour2;
	if ( Index == 3 )	return Colour3;
	if ( Index == 4 )	return Colour4;
	if ( Index == 5 )	return Colour5;
	if ( Index == 6 )	return Colour6;
	if ( Index == 7 )	return Colour7;
	if ( Index == 8 )	return Colour8;
	if ( Index == 9 )	return Colour9;
	if ( Index < 0 )
	return vec3(1,0,1);
	else
	return vec3(0,1,0);
}

void main()
{
	float Distance = texture2D( SdfTexture, uv ).a;
	vec3 Colour = texture2D( HorseTexture, uv ).xyz;
	gl_FragColor = vec4(Colour,1);
	
	float BorderDistance = 1.0;
	float EdgeDistance = 0.999;
	if ( Distance >= EdgeDistance )
	{
		float Blur = (Distance-EdgeDistance) / (BorderDistance-EdgeDistance);
		gl_FragColor.xyz = mix( gl_FragColor.xyz, vec3(0,0,0), 1.0-Blur );
	}
	else
	{
		int StripeCount = 11;
		float SpeedSclar = 3.0;
		Distance += Time / SpeedSclar;
		Distance *= float(StripeCount);
		float Stripef = mod( Distance, float(ColourCount-1) );
		int Stripe = int(Stripef);
		gl_FragColor.xyz = GetColour( Stripe );
	}
}
`;


var FragShader_Copy = `
precision highp float;
varying vec2 uv;
uniform sampler2D ColourTexture;
void main()
{
	gl_FragColor = texture2D( SdfTexture, uv );
}
`;

	window.onload = main;

	function main()
	{
		var Canvas = document.getElementById('glcanvas');
		var Context = new TContext( Canvas );
		var Screen = new TScreen( Canvas );

		var ResizeCanvas = function()
		{
			console.log("ResizeCanvas");
			Canvas.width = window.innerWidth;
			//	gr: where did this border come from?
			Canvas.height = window.innerHeight+4;
			
			/* re-get the 1:1 ratio for the app later
			 
			 //	change viewport so clip space is -1..1
			 //	keep 1:1 ratio
			 let size = Math.max( canvas.width, canvas.height );
			 gl.viewport(0, 0, size, size);
			 */
			
			//	force render in case there's any gaps in animation
			//Render();
		}

		// resize the canvas to fill browser window dynamically
		window.addEventListener('resize', ResizeCanvas, false);
		ResizeCanvas();







		var Time = 0;
		
		let CanvasGeo = new TGeometry("Canvas");
		let Uvs = [
			new float2( 0, 0 ),
			new float2( 1, 0 ),
			new float2( 0, 1 ),
			new float2( 1, 1 ),
		];
		CanvasGeo.AddAttribute( new TAttribute("a_position", Uvs ) );
		
		
		let LayerTexture = new TTexture( "Layer", 100, 100 );
		let LayerTarget = new TRenderTarget( "Layer", LayerTexture );
		
		function Render()
		{
			Time += 1.0 / 60.0;
			
			var Colours = [
			'ADFF5FFF',
			'FFF15FFF',
			'FFB25FFF',
			'FF5F83FF',
			'FF5FFFFF',
			'C15FFFFF',
			'865FFFFF',
			'5F8EFFFF',
			'5FD1FFFF',
			'5FFFD1FF',
			];
			
            
			try
			{
                Screen.Bind();
				// Draw the object given a set of 2D points, in this case a square
				drawObject( shaderProgram, CanvasGeo, SdfTexture, HorseTexture, Time, Colours );
			}
			catch(Exception)
			{
				//	rethrow
				throw Exception;
			}
			finally
			{
				//	always request redraw
				requestAnimationFrame( Render );
			}
		}
		
		


		// Setup the shader program with the vertex shader and the fragment shader
		var shaderProgram = buildShaderProgram(gl,VertexShader,FragShader_SdfHorse);
		
		var SdfUrl = 'http://electric.horse/horse_sdf.png';
		var HorseUrl = 'http://electric.horse/horse.jpg';
		var SdfTexture = new TTexture("sdf",SdfUrl);
		var HorseTexture = new TTexture("Horse",HorseUrl);
      
        var RenderTarget = new TRenderTarget("TestRenderTarget", )


		Render();
	}

	// Create a GLSL shader program given:
	// - a WebGL context,
	// - a string for the vertex shader, and
	// - a string for the fragment shader.
	function buildShaderProgram(gl, vertShaderSrc, fragShaderSrc)
	{
		function buildShader(type, source)
		{
			var sh;
			if (type == "fragment")
				sh = gl.createShader(gl.FRAGMENT_SHADER);
			else if (type == "vertex")
				sh = gl.createShader(gl.VERTEX_SHADER);
			else // Unknown shader type
				return null;
			gl.shaderSource(sh, source);
			gl.compileShader(sh);
			// See if it compiled successfully
			if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
				console.log("An error occurred compiling the " + type +
				" shader: " + gl.getShaderInfoLog(sh));
				return null;
			} else { return sh; }
		};
		
		var prog = gl.createProgram();
		gl.attachShader(prog, buildShader('vertex', vertShaderSrc));
		gl.attachShader(prog, buildShader('fragment', fragShaderSrc));
		gl.linkProgram(prog);
		if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
			throw "Could not link the shader program!";
		}
		return prog;
	}


	// Draw an object given a shader program and a list of vertices
	function drawObject(shaderProgram, Geo, SdfTexture, HorseTexture, Time, Colours )
	{
		gl.useProgram(shaderProgram);

        BindTexture( SdfTexture, shaderProgram, 'SdfTexture', 0 );
        BindTexture( HorseTexture, shaderProgram, 'HorseTexture', 1 );
        
		let TimeUniform = gl.getUniformLocation(shaderProgram, "Time");


		let ColourCountUniform = gl.getUniformLocation(shaderProgram, "ColourCount");
		gl.uniform1i(ColourCountUniform, Colours.length);
		
		// Set black as the background color
		gl.clearColor(0, 0, 0, 1); // defaults to white (1,1,1)
		// Manually clear the canvas.
		gl.clear(gl.COLOR_BUFFER_BIT);





		//	gr; can't use less than with this xml html
		for ( let i=0;	i<Colours.length;	i++ )
		{
			let ColourUniform = gl.getUniformLocation(shaderProgram, "Colour" + i );
			gl.uniform3f(ColourUniform, GetRed(Colours[i]), GetGreen(Colours[i]), GetBlue(Colours[i]) );
		}
		gl.uniform1f(TimeUniform, Time);
		let PositionUniform = gl.getAttribLocation(shaderProgram, "a_position");


		//	setup buffer
		if ( Geo.Buffer == null )
		{
			//Geo.CreateBuffer();
			Geo.Buffer = gl.createBuffer();
			gl.bindBuffer( gl.ARRAY_BUFFER, Geo.Buffer );
			
			//	all interleaved vertex data
			let Attrib = Geo.Attributes[0];
			//	gr: need to convert to array of floats...
			let VertexData = Geo.GetVertexData();
			gl.bufferData( gl.ARRAY_BUFFER, VertexData, gl.STATIC_DRAW );
			gl.enableVertexAttribArray( PositionUniform );
			let Normalised = false;
			let StrideBytes = 0;
			let OffsetBytes = 0;
			gl.vertexAttribPointer( PositionUniform, Attrib.Size, Attrib.Type, Normalised, StrideBytes, OffsetBytes );
			Geo.VertexCount = Attrib.Data.length;
		}

		gl.bindBuffer( gl.ARRAY_BUFFER, Geo.Buffer );
		gl.enableVertexAttribArray( PositionUniform );
		gl.drawArrays( gl.TRIANGLE_STRIP, 0, Geo.VertexCount );
	}



</script></body>
</html>
